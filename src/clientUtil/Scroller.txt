package clientUtil;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.concurrent.Callable;

import org.jline.utils.NonBlockingReader;

import clientUtil.Keyboard.Key;
import clientUtil.Keyboard;

public class Scroller {
    private String RESET;
    private String HIGHLIGHT;

    @FunctionalInterface 
    public interface OptionDisplayer {
        void display(PrintWriter writer,Option option,Object ...args);
    }

    @FunctionalInterface
    public interface ElementDisplayer {
        void display(PrintWriter writer,Callable<Void> element);
    }

    private Option[] options;
    private ArrayList<Callable<Void>> elements;
    private ArrayList<Key> back;
    private ArrayList<Key> forward;
    private ArrayList<Key> select;
    private ArrayList<Key> exit;
    private int currentIndex;
    private NonBlockingReader reader;
    //if bypass send is false it's assumed that the scroller is used to select an option
    private boolean bypassSend;
    private boolean resetWhenOptionChange;
    private boolean resetWhenElementsChange;

    private Scroller(NonBlockingReader reader,Option[] options,ArrayList<Callable<Void>> elements,boolean bypassSend){
        this.RESET = "\033[0m";
        this.HIGHLIGHT = "\033[47;30m";
        this.options = null;
        this.elements = new ArrayList<Callable<Void>>();
        this.back = new ArrayList<Key>();
        this.forward = new ArrayList<Key>();
        this.select = new ArrayList<Key>();
        this.exit = new ArrayList<Key>();
        this.currentIndex = 0;
        this.bypassSend = false;
        this.reader = reader;
    }
    //constructor with options
    public Scroller(NonBlockingReader reader,Option[] options,boolean resetWhenOptionChange){
        this(reader,options,null,false);
    }

    //constructor with elements
    public Scroller(NonBlockingReader reader,ArrayList<Callable<Void>> elements,boolean resetWhenElementsChange){
        this(reader,null,elements,false);
    }

    //setters
    public Scroller setRESET(String RESET){
        this.RESET = RESET;
        return this;
    }
    public Scroller setHIGHLIGHT(String HIGHLIGHT){
        this.HIGHLIGHT = HIGHLIGHT;
        return this;
    }
    public Scroller setBypassSend(boolean bypassSend){
        this.bypassSend = bypassSend;
        return this;
    }
    public Scroller setReader(NonBlockingReader reader){
        this.reader = reader;
        return this;
    }
    public Scroller setOptionSet(Option[] set){
        this.options = set;
        if(this.resetWhenOptionChange){
            this.currentIndex = 0;
        }
        return this;
    }
    public Scroller setElements(ArrayList<Callable<Void>> elements){
        this.elements = elements;
        if(this.resetWhenElementsChange){
            this.currentIndex = 0;
        }
        return this;
    }
    public Scroller setResetOptionSet(boolean reset){
        this.resetWhenOptionChange = reset;
        return this;
    }
    public Scroller setResetElements(boolean reset){
        this.resetWhenElementsChange = reset;
        return this;
    }

    public Scroller addBackKeys(Key ...keys){
        for(Key k : keys){
            this.back.add(k);
        } return this;
    }
    public Scroller addForwardKeys(Key ...keys){
        for(Key k : keys){
            this.forward.add(k);
        } return this;
    }
    public Scroller addSelectKeys(Key ...keys){
        for(Key k : keys){
            this.select.add(k);
        } return this;
    }

    public Scroller addExitKeys(Key ...keys){
        for(Key k : keys){
            this.exit.add(k);
        } return this;
    }

    public int getCurrentIndex(){
        return this.currentIndex;
    }

    public Scroller setCurrentIndex(int index){
        this.currentIndex = index;
        return this;
    }

    public Callable<Void> select(){
        Key key = Keyboard.readKey(this.reader);
        if(back.contains(key)){
            //flippo l'indice indietro
        } else if(forward.contains(key)){
            //flippo l'indice avanti
        } else if(select.contains(key))

    }

    
    
}
